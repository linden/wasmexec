<!DOCTYPE html>
<script>
	// fetch wasm exec.
	import("/wasm_exec.js").then(async () => {
		{{if .FS}}
		const FS = async (method, options) => {
			const response = await fetch(`/fs/${method}`, {
				headers: {
					"content-type": "application/json",
					"accept": "application/json"
				},
				method: "POST",
				body: JSON.stringify(options)
			});

			if (!response.ok) {
				throw new Error(`failed to make file system request: ${await response.text()}`);
			}

			return await response.json();
		}

		const forward = (method, options, callback) => {
			FS(method, options).then((result) => {
				if (result[0]) {
					const error = new Error(result[0]);
					// we need a code otherwise we'll panic. falling back to "fault" here.
					// https://github.com/golang/go/blob/8da6405e0db80fa0a4136fb816c7ca2db716c2b2/src/syscall/fs_js.go#L563.
					error.code = "EFAULT";

					callback(error);
					return;
				}

				callback(...result);
			});
		}

		const write = globalThis.fs.write.bind(globalThis.fs);

		let outputBuf = "";

		const encoder = new TextEncoder("utf-8");
		const decoder = new TextDecoder("utf-8");

		globalThis.fs = {
			constants: {
				O_WRONLY: {{.Flags.O_WRONLY}},
				O_RDWR: {{.Flags.O_RDWR}},
				O_CREAT: {{.Flags.O_CREAT}},
				O_TRUNC: {{.Flags.O_TRUNC}},
				O_APPEND: {{.Flags.O_APPEND}},
				O_EXCL: {{.Flags.O_EXCL}}
			},
			writeSync(fd, buf) {
				outputBuf += decoder.decode(buf);
				const nl = outputBuf.lastIndexOf("\n");
				if (nl != -1) {
					console.log(outputBuf.substring(0, nl));
					outputBuf = outputBuf.substring(nl + 1);
				}
				return buf.length;
			},
			write(fd, buffer, offset, length, position, callback) {
				if (offset !== 0 || length !== buffer.length || position !== null) {
					callback(enosys());
					return;
				}

				if (fd < 3) {
					write(fd, buffer, offset, length, position, callback);
					return;
				}

				// decode the buffer, easier to work with as a string.
				const decoded = decoder.decode(buffer);

				forward("write", { fd, buffer: decoded, offset, length, position }, callback);
			},
			chmod(path, mode, callback) {
				forward("chmod", { path, mode }, callback);
			},
			chown(path, uid, gid, callback) {
				forward("chown", { path, uid, gid }, callback);
			},
			close(fd, callback) {
				forward("close", { fd }, callback);
			},
			fchmod(fd, mode, callback) {
				forward("fchmod", { fd, mode }, callback);
			},
			fchown(fd, uid, gid, callback) {
				forward("fchown", { fd, uid, gid }, callback);
			},
			fstat(fd, callback) {
				forward("fstat", { fd }, (...args) => {
					if (args[0]) {
						return callback(args[0]);
					}

					args[1].isDirectory = () => args[1].dir;

					callback(...args);
				});
			},
			fsync(fd, callback) {
				callback(null);
			},
			ftruncate(fd, length, callback) {
				forward("ftruncate", { fd, length }, callback);
			},
			lchown(path, uid, gid, callback) {
				forward("lchown", { path, uid, gid }, callback);
			},
			link(path, link, callback) {
				forward("link", { path, link }, callback);
			},
			lstat(path, callback) {
				forward("lstat", { path }, callback);
			},
			mkdir(path, perm, callback) {
				forward("mkdir", { path, perm }, callback);
			},
			open(path, flags, perm, callback) {
				forward("open", { path, flags, perm }, callback);
			},
			read(fd, buffer, offset, length, position, callback) {
				forward("read", { fd, buffer, offset, length, position }, (...args) => {
					if (args[0]) {
						return callback(args[0]);
					}

					// decode the value.
					const value = Uint8Array.from(
						// []byte is always encoded in base64.
						atob(args[2]),
						// https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem.
						(c) => c.codePointAt(0)
					);

					// update the buffer.
					buffer.set(value);

					// set the returned value to the buffer.
					args[2] = buffer;

					return callback(...args);
				});
			},
			readdir(path, callback) {
				forward("readdir", { path }, callback);
			},
			readlink(path, callback) {
				forward("readlink", { path }, callback);
			},
			rename(from, to, callback) {
				forward("rename", { from, to }, callback);
			},
			rmdir(path, callback) {
				forward("rmdir", { path }, callback);
			},
			stat(path, callback) {
				forward("stat", { path }, callback);
			},
			symlink(path, link, callback) {
				forward("symlink", { path, link }, callback);
			},
			truncate(path, length, callback) {
				forward("truncate", { path, length }, callback);
			},
			unlink(path, callback) {
				forward("unlink", { path }, callback);
			},
			utimes(path, atime, mtime, callback) {
				forward("utimes", { path, atime, mtime }, callback);
			}
		};

		globalThis.process.cwd = () => {
			return {{.CWD}};
		}
		{{end}}

		// create a new program.
		const go = new Go();

		// add the program arguments.
		go.argv = [{{range $i, $item := .Args}} {{if $i}}, {{end}} "{{$item}}" {{end}}];

		// stream the runtime.
		const { instance } = await WebAssembly.instantiateStreaming(fetch("main.wasm"), go.importObject);

		// execute the program.
		await go.run(instance);

		// signal the program has exited.
		console.log("wasmexec:exit");
	});
</script>